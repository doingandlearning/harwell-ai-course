# Module 2: Core Prompt Engineering Principles

## Learning objectives

- Write developer-focused prompts that are clear, contextual, and constrained.
- Apply zero-shot, few-shot, and chain-of-thought prompting appropriately.
- Iteratively refine prompts when output is wrong or incomplete (“debugging” prompts).
- Use these techniques for technical problem-solving in chat tools (e.g. MS Copilot).

## Suggested talking points

- The developer’s prompt: clarity (task + format), context (stack, file, constraints), and constraints (language, style, don’ts).
- Zero-shot vs. few-shot: when to add examples; when one example changes everything.
- Chain-of-thought: asking for step-by-step reasoning when accuracy matters.
- Iterative refinement: how to read bad output and adjust the prompt (add context, tighten instructions, add examples).
- Prompting as a skill vs. a means to better code (align with audience: productivity vs. understanding).

## Suggested demos

- Same task, three prompts: vague → clear → constrained; show improvement in output quality.
- Few-shot demo: one technical task without examples vs. with 1–2 short examples.
- “Debug a prompt” live: take a weak answer, identify what’s missing, rewrite the prompt, show the improvement.
- Optional: chain-of-thought on a small debugging or design question.

## Suggested exercises

- **Lab:** Craft effective prompts for a technical problem (e.g. “explain this regex” or “suggest a refactor”) using technical chat / MS Copilot; compare with a partner.
- **Refinement:** Take one prompt that produced poor output; rewrite it using clarity, context, and constraints; re-run and compare.
- **Swap:** Exchange prompts with another attendee; run each other’s prompt and suggest one improvement.

## Suggested running time

60–75 minutes (including lab)
